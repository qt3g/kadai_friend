/* PAE05_rp
-------------------------------------------------- ---------------
「プログラミング応用実験」 連結リストとグラフ構造(2)
課題レポートプログラム
-------------------------------------------------- ---------------
??を含むコメントを正しいプログラムコードで置き換える。
プログラムの他の部分は変更しないこと。

マクロIDに各自の学生番号，NAMEに氏名を文字列として定義すること．
例
#ID「19A5999」を定義
#define 名前「工大次郎」
*/
#define ID "/*?? 学生番号 */"
#define NAME "/*?? 氏名 */"

#include "stdio.h"

#define INF 10000 // 辺の重みの最大値より大きい値
#define MAX_SIZE 7 // ノードの数

/*------------------------------------------------ ------------
連結グラフの隣接列
0は接続されていないことを示す．
正の数は接続されている場合の重みを示す
*/
int 重み[MAX_SIZE][MAX_SIZE];

/*---------------------------------
最小広木の隣列
0は接続されていないことを示す．
1は接続されていることを示す．
以下のプログラムで、最低限木の辺となる場所に重みを設定していきます。
*/
int sptree[MAX_SIZE][MAX_SIZE];

/*------------------------------------------------ ------------
連結グラフの隣接列を読み込み，重みを初期化する．
*/
int read_matrix(const char *fn )
{
    ファイル*fp;
    int i、j、c;

    fp = fopen(fn, "r");
    if (fp == NULL) は -1 を返します。

	/* ファイルから読み取った値で，重みを初期化する */
    for(i=0 ;i<MAX_SIZE;i+=1) {
        for(j=0; j<MAX_SIZE; j+=1) {
            fscanf(fp, /*??*/, /*??*/);
            体重[/*??*/][/*??*/] = c;
        }
    }

    fclose(fp);

    0を返します。
}

//------------------------------------------------ ------------
int main()
{
    /* 頂点の状態：used
    used[i]が0：頂点iが未処理であることを示す．
    used[i]が1：頂点iが処理済であることを示します。
    int used[MAX_SIZE] = { 0, 0, 0, 0, 0, 0, 0 };
    int の合計コスト; // 全域最小木の辺のコストの和

    int k, n;
    int p1、p2;
    int m1、m2;
    int i, j;

    /* ??最小最も木の隣列（sptree）の全要素を0で初期化する */






	/* 連結グラフの隣接列をファイル am.txt から読み込む */
    read_matrix("am.txt");

    合計コスト = 0;
    used[0] = /* 頂点0を処理済みに設定する */;

    for(n = 1; n < MAX_SIZE; n += 1) { // 未処理の頂点がなくなるまで続く
        //!printf("================\nn=%d\n", n);

        m1 = INF;
        for(int i=0; i<(MAX_SIZE-1); i+=1) { // 未処理の展望を探す
            if(/*?? 頂点iが処理済の条件*/) {
                //!printf("i=%d>>>>\n", i);

                m2 = INF;
                for(int j=0; j<MAX_SIZE; j+=1) { //すべての展望の中で未処理の展望を探す
                    int w = /*??*/; // wに辺(i, j)の重み（コスト）の値を設定

                    if( /*?? 頂点jが未処理，かつ，頂点(i,j)が接続されている条件*/ ) {
                        //!printf(" j=%d : w(%d,%d)=%d", j, i, j,w);

                        if(m2 > w) { // 新しい最小コストwが届いた
                            /*??*/; // m2の値を更新
                            /*??*/; // kの値を更新
                            //!printf(" - k=%d, m2=%d 更新されました。", k, m2);
                        }

                        //!printf("\n");
                    }
                }

                if((m2 < INF) && /*??*/) { // m2 が見つかりました、それまでの m1 より小さい場合
                    m1 = m2;
                    p1 = i;
                    p2 = k;
                    //!printf(" --------\n #### p1=%d, p2=%d, m1=%d が更新されました。\n", p1, p2, m1);
                }
            }
        }

        //!printf("--------\n%d-%d (%d)\n", p1, p2, m1);
        printf("%d-%d (%d)\n", p1, p2, m1);

        使用[p2] = 1; // 頂点p2を処理済とする

        // ここまでで，頂上p1, p2が接続されており，その重みがm1となっている．

        // 最小範囲木の隣接列の設定
        sptree[/*??*/][/*??*/] = m1;
        sptree[/*??*/][/*??*/] = m1;

        合計コスト += m1; // 全域最小木の辺のコストの和の更新
    }

    printf("総コスト = %d\n", total_cost);

    // 最小範囲木の隣接列sptreeの表示
    for(i = 0; i < MAX_SIZE; i += 1) {
        for(j = 0; j < MAX_SIZE; j += 1) {
            printf("%d ", sptree[i][j]);
        }

        printf("\n");
    }

    printf("\nPAE05: %s %s\n", ID, NAME);


    0を返します。
}

/*実行結果を貼り付ける


*/


//=============================================== =========
/* 共同作業者がいれば，以下にコメントとして学生番号と氏名を示すこと．


*/
